in this code the swagger UI is not working in the generatorRoutes.js make it work properly so that everything in the page is visible in the "http://localhost:$3000/api-docs" link without chnaging the base of the code and everything keeping the same 

// src/config/database.js
const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
    try {
        console.log('Attempting to connect to MongoDB...');
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

module.exports = connectDB;






// src/config/models.json
{
  "MODEL": ["GEMINI", "OPENAI", "CLAUDE"],
  "DEFAULT": "GEMINI",
  "GEMINI": {
      "NAME": "Gemini",
      "URL": "https://gemini.com/",
      "GEMINI_API_KEY": "AIzaSyARy3fYtDPg45Kl4IwlXShmhlsLtoTqB7c",
      "top_k": 5
  },
  "OPENAI": {
      "NAME": "OpenAI",
      "URL": "https://api.openai.com/",
      "OPENAI_API_KEY": "",
      "model": "gpt-4"
  },
  "CLAUDE": {
      "NAME": "Claude",
      "URL": "https://claude.com/",
      "CLAUDE_API_KEY": "",
      "model": "claude-1.0"
  }
}





// src/models/ChatsFinal.js
const mongoose = require('mongoose');

const chatSchema = new mongoose.Schema({
    requestType: {
        type: String,
        enum: ['content', 'title', 'meta', 'keywords', 'all'],
        required: true
    },
    input: {
        type: String,
        required: true
    },
    output: {
        type: mongoose.Schema.Types.Mixed,
        required: true
    },
    metadata: {
        processTime: Number,
        tokensUsed: Number,
        timestamp: {
            type: Date,
            default: Date.now
        }
    }
});

module.exports = mongoose.model('ChatsFinal', chatSchema);



// src/models/models.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');
const path = require('path');
const fs = require('fs');

// Loading the configuration from JSON file
const configPath = path.join(__dirname, '../config/models.json');
const modelsConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));

let currentModel = modelsConfig.DEFAULT;

const isModelAvailable = (modelName) => {
    const config = modelsConfig[modelName];
    switch (modelName) {
        case 'GEMINI':
            return !!config.GEMINI_API_KEY;
        case 'OPENAI':
            return !!config.OPENAI_API_KEY;
        case 'CLAUDE':
            return !!config.CLAUDE_API_KEY;
        default:
            return false;
    }
};

const getAvailableModels = () => {
    return modelsConfig.MODEL.filter(model => isModelAvailable(model));
};

const getModelConfig = () => {
    return modelsConfig[currentModel];
};

const setModel = (model) => {
    const upperModel = model.toUpperCase();
    if (!modelsConfig.MODEL.includes(upperModel)) {
        throw new Error(`Model ${model} not supported.`);
    }
    if (!isModelAvailable(upperModel)) {
        throw new Error(`Model ${model} is not available. API key not configured.`);
    }
    currentModel = upperModel;
    return `Switched to ${modelsConfig[currentModel].NAME} model.`;
};

const getModel = () => {
    const config = getModelConfig();
    if (!isModelAvailable(currentModel)) {
        throw new Error(`Current model ${currentModel} is not available. API key not configured.`);
    }

    switch (currentModel) {
        case 'GEMINI':
            const genAI = new GoogleGenerativeAI(config.GEMINI_API_KEY);
            return genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        case 'OPENAI':
            if (!config.OPENAI_API_KEY) {
                throw new Error('OpenAI API key not configured');
            }
            return new OpenAI({ apiKey: config.OPENAI_API_KEY });
        case 'CLAUDE':
            if (!config.CLAUDE_API_KEY) {
                throw new Error('Claude API key not configured');
            }
            throw new Error('Claude integration not implemented yet');
        default:
            throw new Error(`Model ${currentModel} not supported.`);
    }
};

module.exports = {
    getModel,
    setModel,
    getModelConfig,
    getAvailableModels,
    isModelAvailable
};





// src/routes/generatorRoutes.js

const express = require('express');
const router = express.Router();
const GeneratorService = require('../services/generatorService');
const Chat = require('../models/chatModel');

// keywords endpoint
router.post('/keywords', async (req, res) => {
    try {
        const startTime = Date.now();
        const keywords = await GeneratorService.generateKeywords(req.body.topic);
        
        const chat = new Chat({
            requestType: 'keywords',
            input: req.body.topic,
            output: keywords,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: keywords
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// title endpoint
router.post('/title', async (req, res) => {
    try {
        const startTime = Date.now();
        const titles = await GeneratorService.generateTitle(req.body.topic);
        
        const chat = new Chat({
            requestType: 'title',
            input: req.body.topic,
            output: titles,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: titles
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// meta endpoint
router.post('/meta', async (req, res) => {
    try {
        const startTime = Date.now();
        const meta = await GeneratorService.generateMeta(req.body.topic);
        
        const chat = new Chat({
            requestType: 'meta',
            input: req.body.topic,
            output: meta,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: meta
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// content endpoint
router.post('/content', async (req, res) => {
    try {
        const startTime = Date.now();
        const content = await GeneratorService.generateContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'content',
            input: req.body.topic,
            output: content,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: content
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// switch model endpoint
router.post('/switch-model', async (req, res) => {
    try {
      const { model } = req.body;
      const result = await GeneratorService.switchModel(model);
      res.json({
        success: true,
        message: result
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  router.post('/all', async (req, res) => {
    try {
        const startTime = Date.now();
        const allContent = await GeneratorService.generateAllContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'all',
            input: req.body.topic,
            output: allContent,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: allContent
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;



// src/routes/healthRoutes.js
const express = require('express');
const router = express.Router();
const healthMonitor = require('../healthMonitor.js');

// Health Check endpoint
router.get('/', async (req, res) => {
    try {
        const healthStatus = healthMonitor.getHealthStatus();
        res.json({
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;





// src/services/generatorService.js
const { getModel, setModel, getModelConfig } = require('../models/models');

class GeneratorService {
    static async generateKeywords(topic) {
        try {
            const model = getModel();
            const prompt = `Generate 10 relevant SEO keywords for the topic: ${topic}. 
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for keyword generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate keywords: ${error.message}`);
        }
    }

    static async generateTitle(topic) {
        try {
            const model = getModel();
            const prompt = `Generate 1 engaging title for the topic: ${topic}. 
                           The title should be very attractive and under 60 characters. 
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for title generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate title: ${error.message}`);
        }
    }

    static async generateMeta(topic) {
        try {
            const model = getModel();
            const prompt = `Generate meta description for the topic: ${topic}. 
                           The description should be under 160 characters and SEO optimized. 
                           Return only a JSON object with a single "description" field, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for meta generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate meta: ${error.message}`);
        }
    }

    static async generateContent(topic) {
        try {
            const model = getModel();
            const prompt = `Generate a detailed article about: ${topic}. 
                           Include introduction, main points, and conclusion.
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                return result.response.text();
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return result.choices[0].message.content;
            } else {
                throw new Error('Model not supported for content generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate content: ${error.message}`);
        }
    }

    // In src/services/generatorService.js
    static async generateAllContent(topic) {
        try {
            const [keywords, titles, meta, content] = await Promise.all([
                this.generateKeywords(topic),
                this.generateTitle(topic),
                this.generateMeta(topic),
                this.generateContent(topic)
            ]);

            return {
                keywords,
                titles,
                meta,
                content
            };
        } catch (error) {
            throw new Error(`Failed to generate all content: ${error.message}`);
        }
    }

    static async switchModel(model) {
        try {
            const result = setModel(model);
            return result;
        } catch (error) {
            throw new Error(`Failed to switch model: ${error.message}`);
        }
    }
}

module.exports = GeneratorService;





// src/app.js
const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerJsdoc = require('swagger-jsdoc');
const connectDB = require('./config/database');
const healthMonitor = require('./healthMonitor');
require('dotenv').config();

const app = express();

// Connect to MongoDB
connectDB();

// Middleware
app.use(express.json());

// to start the health monitoring
healthMonitor.startMonitoring();

app.use('/api/health', require('./routes/healthRoutes'));

// Swagger configuration - only for generator routes
const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Content Generation API',
            version: '1.0.0',
            description: 'API for generating various types of content'
        },
        servers: [
            {
                url: `http://localhost:${process.env.PORT || 3000}`
            }
        ]
    },
    apis: ['./routes/generatorRoutes.js']
    
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

app.use('/api/generate', require('./routes/generatorRoutes'));

// Error handling
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
        success: false,
        error: 'Something went wrong!'
    });
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
    // Logging initial health status
    healthMonitor.logHealthStatus();

    console.log(`Server running on port ${port}`);
    console.log(`Swagger documentation available at http://localhost:${port}/api-docs`);
});

module.exports = app;





// src/cli.js
const readline = require('readline');
const axios = require('axios');
const GeneratorService = require('./services/generatorService');

process.removeAllListeners('warning');
process.on('warning', (warning) => {
  if (warning.name === 'DeprecationWarning' && warning.message.includes('punycode')) {
    return;
  }
  console.warn(warning.name, warning.message);
});

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const API_URL = 'http://localhost:3000';

const COMMANDS = {
  SWITCH: '/switch',
  EXIT: 'exit',
  HELP: '/help',
  HEALTH: '/health',
  MODEL: '/model'
};

const AVAILABLE_MODELS = ['GEMINI', 'OPENAI', 'CALUDE'];

async function showHelp() {
  console.log('\nAvailable commands:');
  console.log('/model  - Switch between AI models');
  console.log('/switch - Switch between modes');
  console.log('/health - Show current system health');
  console.log('exit   - Exit current mode or program');
  console.log('/help  - Show this help message\n');
}

async function displayHealthCheck() {
  try {
    const response = await axios.get(`${API_URL}/api/health`);
    console.log('\nSystem Health Status:');
    console.log('===================');
    console.log(JSON.stringify(response.data.data, null, 2));
    console.log('===================\n');
  } catch (error) {
    console.error('Error fetching health status:', error.message);
  }
}

async function switchModel() {
  return new Promise((resolve) => {
    console.log('\nAvailable Models:');
    AVAILABLE_MODELS.forEach((model, index) => {
      console.log(`${index + 1}. ${model}`);
    });
    
    rl.question('\nSelect model (1-3): ', async (choice) => {
      const modelIndex = parseInt(choice) - 1;
      if (modelIndex >= 0 && modelIndex < AVAILABLE_MODELS.length) {
        try {
          const result = await GeneratorService.switchModel(AVAILABLE_MODELS[modelIndex]);
          console.log(`\n${result}`);
          resolve(true);
        } catch (error) {
          console.error('Error switching model:', error.message);
          resolve(false);
        }
      } else {
        console.log('\nInvalid selection. Using default model.');
        resolve(false);
      }
    });
  });
}

async function handleGeneratorMode() {
  console.clear();
  console.log('\n=== Content Generator Mode ===');
  console.log('Select content type to generate:');
  console.log('1. Keywords');
  console.log('2. Title Suggestions');
  console.log('3. Meta Description');
  console.log('4. Full Content');
  console.log('5. Generate all together');
  console.log('Type "exit" to return to main menu');
  console.log('Type "/help" for available commands\n');

  const generator = async () => {
      try {
          rl.question('Select option (1-5): ', async (option) => {
                if (option.toLowerCase() === COMMANDS.EXIT) {
                    console.clear();
                    showMainMenu();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.HELP) {
                    await showHelp();
                    generator();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.HEALTH) {
                    await displayHealthCheck();
                    generator();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.MODEL) {
                    await switchModel();
                    generator();
                    return;
                }

                let endpoint;
                let prompt;

                switch (option) {
                  case '1':
                      endpoint = '/api/generate/keywords';
                      prompt = 'Enter topic for keyword generation: ';
                      break;
                  case '2':
                      endpoint = '/api/generate/title';
                      prompt = 'Enter topic for title suggestions: ';
                      break;
                  case '3':
                      endpoint = '/api/generate/meta';
                      prompt = 'Enter topic for meta description: ';
                      break;
                  case '4':
                      endpoint = '/api/generate/content';
                      prompt = 'Enter topic for content generation: ';
                      break;
                  case '5':
                      endpoint = '/api/generate/all';
                      prompt = 'Enter topic to generate all content types: ';
                      break;
                  default:
                      console.log('Invalid option. Please choose 1-5.\n');
                      generator();
                      return;
              }

              rl.question(prompt, async (topic) => {
                  try {
                      console.log('\nGenerating content...\n');
                      const response = await axios.post(`${API_URL}${endpoint}`, { topic });
                      
                      console.log('Generated Successfully!\n');
                      console.log(JSON.stringify(response.data.data, null, 2));
                      console.log('\nSelect another option or type "exit" to return to main menu\n');
                  } catch (error) {
                      console.error('Error generating content:', error.response?.data?.error || error.message);
                  }
                  generator();
              });
          });
      } catch (error) {
          console.error('Error in generator mode:', error.message);
          generator();
      }
  };

  generator();
}


async function handleChatMode() {
  console.clear();
  console.log('\n=== Chat Mode ===');
  console.log('Type your message or use commands (/help for list)\n');

  const chat = async () => {
    try {
      rl.question('You: ', async (input) => {
        if (input.toLowerCase() === COMMANDS.EXIT) {
          console.clear();
          showMainMenu();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HEALTH) {
          await displayHealthCheck();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          chat();
          return;
        }

        try {
          const response = await axios.post(`${API_URL}/api/generate/content`, { topic: input });
          console.log('\nAI:', response.data.data, '\n');
        } catch (error) {
          console.error('Error in chat:', error.response?.data?.error || error.message);
        }
        chat();
      });
    } catch (error) {
      console.error('Error in chat mode:', error.message);
      chat();
    }
  };

  chat();
}

async function initialModelSelection() {
  console.log('Welcome to Content Generation CLI!\n');
  console.log('Please select your preferred AI model:');
  await switchModel();
}

async function showMainMenu() {
  console.log('\nAvailable modes:');
  console.log('1. Generator - Generate specific content types');
  console.log('2. Chat - Free conversation mode');
  console.log('Type "exit" to quit the program');
  console.log('Type "/help" for available commands\n');

  const selectMode = () => {
    try {
      rl.question('Select mode (1/2): ', async (mode) => {
        if (mode.toLowerCase() === COMMANDS.EXIT) {
          console.log('Goodbye!');
          rl.close();
          process.exit(0);
        }

        if (mode.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          selectMode();
          return;
        }

        if (mode.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          selectMode();
          return;
        }

        switch (mode) {
          case '1':
            await handleGeneratorMode();
            break;
          case '2':
            await handleChatMode();
            break;
          default:
            console.log('Invalid selection. Please choose 1 or 2.\n');
            selectMode();
        }
      });
    } catch (error) {
      console.error('Error in main menu:', error.message);
      selectMode();
    }
  };

  selectMode();
}

async function startChat() {
  console.clear();
  await initialModelSelection();
  showMainMenu();
}

// Handle process termination gracefully
process.on('SIGINT', () => {
  console.log('\nGoodbye!');
  rl.close();
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  rl.close();
  process.exit(1);
});

module.exports = startChat;




// src/healthMonitor.js
const mongoose = require('mongoose');

class HealthMonitor {
    constructor() {
        this.interval = null;
    }

    getHealthStatus() {
        return {
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available',
            timestamp: new Date().toISOString()
        };
    }

    logHealthStatus() {
        const status = this.getHealthStatus();
        console.log('\nSystem Health Status:');
        console.log('===================');
        console.log(`Status: ${status.status}`);
        console.log(`Uptime: ${status.uptime.toFixed(2)} seconds`);
        console.log(`Database: ${status.databaseStatus}`);
        console.log(`AI Model: ${status.aiModelStatus}`);
        console.log(`Timestamp: ${status.timestamp}`);
        console.log('===================\n');
    }

    startMonitoring(interval = 60000) {
        this.interval = setInterval(() => this.logHealthStatus(), interval);
    }

    stopMonitoring() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
    }
}

module.exports = new HealthMonitor();