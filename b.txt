const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
    try {
        console.log('Attempting to connect to MongoDB...');
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

module.exports = connectDB;





// 2. src/models/chatModel.js
const mongoose = require('mongoose');

const chatSchema = new mongoose.Schema({
    requestType: {
        type: String,
        enum: ['content', 'title', 'meta', 'keywords'],
        required: true
    },
    input: {
        type: String,
        required: true
    },
    output: {
        type: mongoose.Schema.Types.Mixed,
        required: true
    },
    metadata: {
        processTime: Number,
        tokensUsed: Number,
        timestamp: {
            type: Date,
            default: Date.now
        }
    }
});

module.exports = mongoose.model('ChatsFinal', chatSchema);





const modelsConfig = require('./models.json');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');

let currentModel = modelsConfig.DEFAULT;

const getModelConfig = () => {
  return modelsConfig[currentModel];
};

const setModel = (model) => {
  if (modelsConfig.MODEL.includes(model.toUpperCase())) {
    currentModel = model.toUpperCase();
  } else {
    throw new Error(`Model ${model} not supported.`);
  }
};

const getModel = () => {
  const config = getModelConfig();
  switch (currentModel) {
    case 'GEMINI':
      const genAI = new GoogleGenerativeAI(config.GEMINI_API_KEY);
      return genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
    case 'OPENAI':
      const openai = new OpenAI({ apiKey: config.OPENAI_API_KEY });
      return openai;
    case 'CALUDE':
      // Implement Calude model initialization here
      throw new Error('Calude model not implemented yet.');
    default:
      throw new Error(`Model ${currentModel} not supported.`);
  }
};

module.exports = { getModel, setModel, getModelConfig };




{
    "MODEL": ["GEMINI", "OPENAI", "CALUDE"],
    "DEFAULT": "GEMINI",
    "GEMINI": {
      "NAME": "Gemini",
      "URL": "https://gemini.com/",
      "GEMINI_API_KEY": "AIzaSyARy3fYtDPg45Kl4IwlXShmhlsLtoTqB7c",
      "top_k": 5
    },
    "OPENAI": {
      "NAME": "OpenAI",
      "URL": "https://api.openai.com/",
      "OPENAI_API_KEY": "",
      "model": "gpt-4"
    },
    "CALUDE": {
      "NAME": "Calude",
      "URL": "https://calude.com/",
      "CALUDE_API_KEY": "",
      "model": "calude-1.0"
    }
  }






// 2. Update generatorRoutes.js to add missing endpoints
const express = require('express');
const router = express.Router();
const GeneratorService = require('../services/generatorService');
const Chat = require('../models/chatModel');

// Existing keywords endpoint
router.post('/keywords', async (req, res) => {
    try {
        const startTime = Date.now();
        const keywords = await GeneratorService.generateKeywords(req.body.topic);
        
        const chat = new Chat({
            requestType: 'keywords',
            input: req.body.topic,
            output: keywords,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: keywords
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Existing title endpoint
router.post('/title', async (req, res) => {
    try {
        const startTime = Date.now();
        const titles = await GeneratorService.generateTitle(req.body.topic);
        
        const chat = new Chat({
            requestType: 'title',
            input: req.body.topic,
            output: titles,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: titles
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add meta endpoint
router.post('/meta', async (req, res) => {
    try {
        const startTime = Date.now();
        const meta = await GeneratorService.generateMeta(req.body.topic);
        
        const chat = new Chat({
            requestType: 'meta',
            input: req.body.topic,
            output: meta,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: meta
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add content endpoint
router.post('/content', async (req, res) => {
    try {
        const startTime = Date.now();
        const content = await GeneratorService.generateContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'content',
            input: req.body.topic,
            output: content,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: content
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add switch model endpoint
router.post('/switch-model', async (req, res) => {
    try {
      const { model } = req.body;
      const result = await GeneratorService.switchModel(model);
      res.json({
        success: true,
        message: result
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

module.exports = router;





const express = require('express');
const router = express.Router();
const mongoose = require('mongoose'); // Import mongoose

/**
 * @swagger
 * /api/health:
 *   get:
 *     summary: Check system health
 *     description: Returns system health status including database and AI model availability
 *     tags: [Health]
 *     responses:
 *       200:
 *         description: System is healthy
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                 uptime:
 *                   type: number
 *                 databaseStatus:
 *                   type: string
 *                 aiModelStatus:
 *                   type: string
 */
router.get('/', async (req, res) => {
    try {
        const healthStatus = {
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available'
        };
        
        res.json({
            success: true,
            data: healthStatus
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;






const { getModel, setModel, getModelConfig } = require('../models/models');

class GeneratorService {
  static async generateKeywords(topic) {
    const model = getModel();
    const prompt = `Generate 10 relevant SEO keywords for the topic: ${topic}. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for keyword generation.');
    }
  }

  static async generateTitle(topic) {
    const model = getModel();
    const prompt = `Generate 1 engaging title for the topic: ${topic}. 
                   The title should be very attractive and under 60 characters. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for title generation.');
    }
  }

  static async generateMeta(topic) {
    const model = getModel();
    const prompt = `Generate meta description for the topic: ${topic}. 
                   The description should be under 160 characters and SEO optimized. 
                   Return only a JSON object with a single "description" field, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for meta generation.');
    }
  }

  static async generateContent(topic) {
    const model = getModel();
    const prompt = `Generate a detailed article about: ${topic}. 
                   Include introduction, main points, and conclusion.
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      return result.response.text();
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return result.choices[0].message.content;
    } else {
      throw new Error('Model not supported for content generation.');
    }
  }

  static async switchModel(model) {
    setModel(model);
    return `Switched to ${getModelConfig().NAME} model.`;
  }
}

module.exports = GeneratorService;





// app.js
const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerJsdoc = require('swagger-jsdoc');
const connectDB = require('./config/database');
const mongoose = require('mongoose');
require('dotenv').config();

const app = express();

// Connect to MongoDB
connectDB();

// Middleware
app.use(express.json());

// Function to get health status
const getHealthStatus = () => {
    const healthStatus = {
        status: 'healthy',
        uptime: process.uptime(),
        databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        aiModelStatus: 'available',
        timestamp: new Date().toISOString()
    };
    return healthStatus;
};

// Regular health status logging
setInterval(() => {
    const status = getHealthStatus();
    console.log('\nSystem Health Status:');
    console.log('===================');
    console.log(`Status: ${status.status}`);
    console.log(`Uptime: ${status.uptime.toFixed(2)} seconds`);
    console.log(`Database: ${status.databaseStatus}`);
    console.log(`AI Model: ${status.aiModelStatus}`);
    console.log(`Timestamp: ${status.timestamp}`);
    console.log('===================\n');
}, 60000); // Log every minute

// Early Health Check endpoint
app.get('/api/health', async (req, res) => {
    try {
        const healthStatus = getHealthStatus();
        res.json({
            success: true,
            data: healthStatus
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Swagger configuration
const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Content Generation API',
            version: '1.0.0',
            description: 'API for generating various types of content'
        },
        servers: [
            {
                url: `http://localhost:${process.env.PORT || 3000}`
            }
        ]
    },
    apis: ['./src/routes/*.js']
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Routes (after health check)
app.use('/api/generate', require('./routes/generatorRoutes'));


// Error handling
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
        success: false,
        error: 'Something went wrong!'
    });
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
    // Initial health status log
    const status = getHealthStatus();
    console.log('\nInitial System Health Status:');
    console.log('===================');
    console.log(`Status: ${status.status}`);
    console.log(`Uptime: ${status.uptime.toFixed(2)} seconds`);
    console.log(`Database: ${status.databaseStatus}`);
    console.log(`AI Model: ${status.aiModelStatus}`);
    console.log(`Timestamp: ${status.timestamp}`);
    console.log('===================\n');

    console.log(`Server running on port ${port}`);
    console.log(`Swagger documentation available at http://localhost:${port}/api-docs`);
    console.log(`Health check endpoint available at http://localhost:${port}/api/health`);
});

module.exports = app;





// cli.js
const readline = require('readline');
const axios = require('axios');
const GeneratorService = require('./services/generatorService');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const API_URL = 'http://localhost:3000';

const COMMANDS = {
  SWITCH: '/switch',
  EXIT: 'exit',
  HELP: '/help',
  HEALTH: '/health'
};

async function showHelp() {
  console.log('\nAvailable commands:');
  console.log('/switch - Switch between models');
  console.log('/health - Show current system health');
  console.log('exit   - Exit current mode or program');
  console.log('/help  - Show this help message\n');
}

async function handleGeneratorMode() {
  console.clear();
  console.log('\n=== Content Generator Mode ===');
  console.log('Select content type to generate:');
  console.log('1. Keywords');
  console.log('2. Title Suggestions');
  console.log('3. Meta Description');
  console.log('4. Full Content');
  console.log('Type "exit" to return to main menu');
  console.log('Type "/help" for available commands\n');

  const generator = async () => {
    rl.question('Select option (1-4): ', async (option) => {
      if (option.toLowerCase() === COMMANDS.EXIT) {
        console.clear();
        showMainMenu();
        return;
      }

      if (option.toLowerCase() === COMMANDS.HELP) {
        await showHelp();
        generator();
        return;
      }

      if (option.toLowerCase() === COMMANDS.HEALTH) {
        await displayHealthCheck();
        generator();
        return;
      }

      if (option.toLowerCase() === COMMANDS.SWITCH) {
        rl.question('Enter model to switch to (GEMINI, OPENAI, CALUDE): ', async (model) => {
          try {
            const result = await GeneratorService.switchModel(model);
            console.log(result);
          } catch (error) {
            console.error(error.message);
          }
          generator();
        });
        return;
      }

      let endpoint;
      let prompt;

      switch (option) {
        case '1':
          endpoint = '/api/generate/keywords';
          prompt = 'Enter topic for keyword generation: ';
          break;
        case '2':
          endpoint = '/api/generate/title';
          prompt = 'Enter topic for title suggestions: ';
          break;
        case '3':
          endpoint = '/api/generate/meta';
          prompt = 'Enter topic for meta description: ';
          break;
        case '4':
          endpoint = '/api/generate/content';
          prompt = 'Enter topic for content generation: ';
          break;
        default:
          console.log('Invalid option. Please choose 1-4.\n');
          generator();
          return;
      }

      rl.question(prompt, async (topic) => {
        try {
          console.log('\nGenerating content...\n');
          const response = await axios.post(`${API_URL}${endpoint}`, { topic });
          console.log('Generated Successfully!\n');
          console.log(JSON.stringify(response.data.data, null, 2));
          console.log('\nSelect another option or type "exit" to return to main menu\n');
        } catch (error) {
          console.error('Error:', error.response?.data?.error || error.message, '\n');
        }
        generator();
      });
    });
  };

  generator();
}

async function handleChatMode() {
    console.clear();
    console.log('\n=== Chat Mode ===');
    console.log('Type your message or use commands (/help for list)\n');

    const chat = async () => {
        rl.question('You: ', async (input) => {
            if (input.toLowerCase() === COMMANDS.EXIT) {
                console.clear();
                showMainMenu();
                return;
            }

            if (input.toLowerCase() === COMMANDS.HELP) {
                await showHelp();
                chat();
                return;
            }

            if (input.toLowerCase() === COMMANDS.HEALTH) {
                await displayHealthCheck();
                chat();
                return;
            }

            if (input.toLowerCase() === COMMANDS.SWITCH) {
                await handleGeneratorMode();
                return;
            }

            try {
                const response = await axios.post(`${API_URL}/api/generate/content`, { 
                    topic: input 
                });
                console.log('\nAI:', response.data.data, '\n');
            } catch (error) {
                console.error('Error:', error.response?.data?.error || error.message, '\n');
            }
            chat();
        });
    };

    chat();
}

function showMainMenu() {
    console.log('Welcome to Content Generation CLI!\n');
    console.log('Available modes:');
    console.log('1. Generator - Generate specific content types');
    console.log('2. Chat - Free conversation mode');
    console.log('Type "exit" to quit the program');
    console.log('Type "/help" for available commands\n');
        
    const selectMode = () => {
        rl.question('Select mode (1/2): ', async (mode) => {
            if (mode.toLowerCase() === COMMANDS.EXIT) {
                console.log('Goodbye!');
                rl.close();
                process.exit(0);
            }

            if (mode.toLowerCase() === COMMANDS.HELP) {
                await showHelp();
                selectMode();
                return;
            }

            

            switch (mode) {
                case '1':
                    await handleGeneratorMode();
                    break;
                default:
                    console.log('Invalid selection. Please choose 1 or 2.\n');
                    selectMode();
            }
        });
    };

    selectMode();
}

function startChat() {
    console.clear();
    showMainMenu();
}

module.exports = startChat;




