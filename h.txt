
const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
    try {
        console.log('Attempting to connect to MongoDB...');
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

module.exports = connectDB;




{
  "MODEL": ["GEMINI", "OPENAI", "CLAUDE"],
  "DEFAULT": "GEMINI",
  "GEMINI": {
      "NAME": "Gemini",
      "URL": "https://gemini.com/",
      "GEMINI_API_KEY": "AIzaSyARy3fYtDPg45Kl4IwlXShmhlsLtoTqB7c",
      "top_k": 5
  },
  "OPENAI": {
      "NAME": "OpenAI",
      "URL": "https://api.openai.com/",
      "OPENAI_API_KEY": "",
      "model": "gpt-4"
  },
  "CLAUDE": {
      "NAME": "Claude",
      "URL": "https://claude.com/",
      "CLAUDE_API_KEY": "",
      "model": "claude-1.0"
  }
}





const mongoose = require('mongoose');

const blogContentSchema = new mongoose.Schema({
    markdown: String,
    json: Object,
    html: String
});

const chatSchema = new mongoose.Schema({
    userInput: {
        type: String,
        required: true
    },
    aiResponse: {
        type: String,
        required: true
    },
    blogContent: blogContentSchema,
    contentType: {
        type: String,
        enum: ['chat'],
        default: 'chat'
    },
    timestamp: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('Chat', chatSchema);







const mongoose = require('mongoose');

const chatSchema = new mongoose.Schema({
    requestType: {
        type: String,
        enum: ['content', 'title', 'meta', 'keywords', 'all'],
        required: true
    },
    input: {
        type: String,
        required: true
    },
    output: {
        type: mongoose.Schema.Types.Mixed,
        required: true
    },
    metadata: {
        processTime: Number,
        tokensUsed: Number,
        timestamp: {
            type: Date,
            default: Date.now
        }
    }
});

module.exports = mongoose.model('ChatsFinal', chatSchema);






const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');
const path = require('path');
const fs = require('fs');

// Loading the configuration from JSON file
const configPath = path.join(__dirname, '../config/models.json');
const modelsConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));

let currentModel = modelsConfig.DEFAULT;

const isModelAvailable = (modelName) => {
    const config = modelsConfig[modelName];
    switch (modelName) {
        case 'GEMINI':
            return !!config.GEMINI_API_KEY;
        case 'OPENAI':
            return !!config.OPENAI_API_KEY;
        case 'CLAUDE':
            return !!config.CLAUDE_API_KEY;
        default:
            return false;
    }
};

const getAvailableModels = () => {
    return modelsConfig.MODEL.filter(model => isModelAvailable(model));
};

const getModelConfig = () => {
    return modelsConfig[currentModel];
};

const setModel = (model) => {
    const upperModel = model.toUpperCase();
    if (!modelsConfig.MODEL.includes(upperModel)) {
        throw new Error(`Model ${model} not supported.`);
    }
    if (!isModelAvailable(upperModel)) {
        throw new Error(`Model ${model} is not available. API key not configured.`);
    }
    currentModel = upperModel;
    return `Switched to ${modelsConfig[currentModel].NAME} model.`;
};

const getModel = () => {
    const config = getModelConfig();
    if (!isModelAvailable(currentModel)) {
        throw new Error(`Current model ${currentModel} is not available. API key not configured.`);
    }

    switch (currentModel) {
        case 'GEMINI':
            const genAI = new GoogleGenerativeAI(config.GEMINI_API_KEY);
            return genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        case 'OPENAI':
            if (!config.OPENAI_API_KEY) {
                throw new Error('OpenAI API key not configured');
            }
            return new OpenAI({ apiKey: config.OPENAI_API_KEY });
        case 'CLAUDE':
            if (!config.CLAUDE_API_KEY) {
                throw new Error('Claude API key not configured');
            }
            throw new Error('Claude integration not implemented yet');
        default:
            throw new Error(`Model ${currentModel} not supported.`);
    }
};

module.exports = {
    getModel,
    setModel,
    getModelConfig,
    getAvailableModels,
    isModelAvailable
};






// src/routes/chatRoutes.js
const express = require('express');
const router = express.Router();
const Chat = require('../models/chatModel');
const { getModel, getModelConfig } = require('../models/models');

/**
 * @swagger
 * tags:
 *   name: Chat
 *   description: Chat interaction endpoints
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ChatRequest:
 *       type: object
 *       required:
 *         - message
 *       properties:
 *         message:
 *           type: string
 *           description: User's input message
 *           example: "Tell me about artificial intelligence"
 *     ChatResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         res:
 *           type: object
 *           properties:
 *             data:
 *               type: string
 *     ChatHistory:
 *       type: object
 *       properties:
 *         userInput:
 *           type: string
 *         aiResponse:
 *           type: string
 *         timestamp:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/chat:
 *   post:
 *     tags: [Chat]
 *     summary: Send a message and get AI response
 *     description: Send a message to the currently selected AI model and receive a response
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ChatRequest'
 *     responses:
 *       200:
 *         description: Successful chat response
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 res:
 *                   type: object
 *                   properties:
 *                     data:
 *                       type: string
 *       500:
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 error:
 *                   type: string
 */
router.post('/', async (req, res) => {
    try {
        const userMessage = req.body.message;
        const model = getModel();
        const modelConfig = getModelConfig();

        let aiResponse;
        if (modelConfig.NAME === 'GEMINI') {
            const result = await model.generateContent(userMessage);
            const response = await result.response;
            aiResponse = response.text();
        } else if (modelConfig.NAME === 'OPENAI') {
            const response = await model.chat.completions.create({
                model: modelConfig.model,
                messages: [{ role: 'user', content: userMessage }]
            });
            aiResponse = response.choices[0].message.content;
        } else {
            throw new Error('Unsupported model for chat');
        }

        const chat = new Chat({
            userInput: userMessage,
            aiResponse: aiResponse,
            modelUsed: modelConfig.NAME
        });
        await chat.save();

        res.json({
            success: true,
            res: {
                data: aiResponse
            }
        });
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * @swagger
 * /api/chat/history:
 *   get:
 *     tags: [Chat]
 *     summary: Get chat history
 *     description: Retrieve the history of all chat interactions
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *         description: Maximum number of records to return
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *         description: Page number for pagination
 *     responses:
 *       200:
 *         description: List of chat interactions
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 res:
 *                   type: object
 *                   properties:
 *                     data:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/ChatHistory'
 *       500:
 *         description: Server error
 */
router.get('/history', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit) || 50;
        const page = parseInt(req.query.page) || 1;
        const skip = (page - 1) * limit;

        const history = await Chat.find()
            .sort({ timestamp: -1 })
            .skip(skip)
            .limit(limit);

        const total = await Chat.countDocuments();

        res.json({
            success: true,
            res: {
                data: history,
                pagination: {
                    total,
                    page,
                    pages: Math.ceil(total / limit)
                }
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;







const express = require('express');
const router = express.Router();
const GeneratorService = require('../services/generatorService');
const Chat = require('../models/ChatsFinal');

/**
 * @swagger
 * tags:
 *   name: Generator
 *   description: Content generation endpoints
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     TopicRequest:
 *       type: object
 *       required:
 *         - topic
 *       properties:
 *         topic:
 *           type: string
 *           description: The topic to generate content for
 *           example: "artificial intelligence in healthcare"
 *     ModelRequest:
 *       type: object
 *       required:
 *         - model
 *       properties:
 *         model:
 *           type: string
 *           description: The AI model to switch to
 *           enum: [GEMINI, OPENAI, CLAUDE]
 *     GeneratorResponse:
 *       type: object
 *       properties:
 *         success:
 *           type: boolean
 *         data:
 *           type: object
 */

/**
 * @swagger
 * /api/generate/keywords:
 *   post:
 *     tags: [Generator]
 *     summary: Generate SEO keywords
 *     description: Generates a list of relevant SEO keywords for the given topic
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/TopicRequest'
 *     responses:
 *       200:
 *         description: Successfully generated keywords
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     type: string
 *       500:
 *         description: Server error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 error:
 *                   type: string
 */
router.post('/keywords', async (req, res) => {
    try {
        const startTime = Date.now();
        const keywords = await GeneratorService.generateKeywords(req.body.topic);
        
        const chat = new Chat({
            requestType: 'keywords',
            input: req.body.topic,
            output: keywords,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: keywords
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * @swagger
 * /api/generate/title:
 *   post:
 *     tags: [Generator]
 *     summary: Generate title suggestions
 *     description: Generates engaging titles for the given topic
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/TopicRequest'
 *     responses:
 *       200:
 *         description: Successfully generated titles
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: array
 *                   items:
 *                     type: string
 *       500:
 *         description: Server error
 */
router.post('/title', async (req, res) => {
    try {
        const startTime = Date.now();
        const titles = await GeneratorService.generateTitle(req.body.topic);
        
        const chat = new Chat({
            requestType: 'title',
            input: req.body.topic,
            output: titles,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: titles
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * @swagger
 * /api/generate/meta:
 *   post:
 *     tags: [Generator]
 *     summary: Generate meta description
 *     description: Generates SEO-optimized meta description for the given topic
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/TopicRequest'
 *     responses:
 *       200:
 *         description: Successfully generated meta description
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     description:
 *                       type: string
 *       500:
 *         description: Server error
 */
router.post('/meta', async (req, res) => {
    try {
        const startTime = Date.now();
        const meta = await GeneratorService.generateMeta(req.body.topic);
        
        const chat = new Chat({
            requestType: 'meta',
            input: req.body.topic,
            output: meta,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: meta
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * @swagger
 * /api/generate/content:
 *   post:
 *     tags: [Generator]
 *     summary: Generate article content
 *     description: Generates detailed article content for the given topic
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/TopicRequest'
 *     responses:
 *       200:
 *         description: Successfully generated content
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: string
 *       500:
 *         description: Server error
 */
router.post('/content', async (req, res) => {
    try {
        const startTime = Date.now();
        const content = await GeneratorService.generateContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'content',
            input: req.body.topic,
            output: content,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: content
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

router.post('/switch-model', async (req, res) => {
    try {
        const { model } = req.body;
        const result = await GeneratorService.switchModel(model);
        res.json({
            success: true,
            message: result
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * @swagger
 * /api/generate/all:
 *   post:
 *     tags: [Generator]
 *     summary: Generate all content types
 *     description: Generates keywords, titles, meta description, and content for the given topic
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/TopicRequest'
 *     responses:
 *       200:
 *         description: Successfully generated all content
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     keywords:
 *                       type: array
 *                       items:
 *                         type: string
 *                     titles:
 *                       type: array
 *                       items:
 *                         type: string
 *                     meta:
 *                       type: object
 *                       properties:
 *                         description:
 *                           type: string
 *                     content:
 *                       type: string
 *       500:
 *         description: Server error
 */
router.post('/all', async (req, res) => {
    try {
        const startTime = Date.now();
        const allContent = await GeneratorService.generateAllContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'all',
            input: req.body.topic,
            output: allContent,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: allContent
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;






const express = require('express');
const router = express.Router();
const healthMonitor = require('../healthMonitor.js');

// Health Check endpoint
router.get('/', async (req, res) => {
    try {
        const healthStatus = healthMonitor.getHealthStatus();
        res.json({
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;








const { getModel, setModel, getModelConfig } = require('../models/models');

class GeneratorService {
    static async generateKeywords(topic) {
        try {
            const model = getModel();
            const prompt = `Generate 10 relevant SEO keywords for the topic: ${topic}. 
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for keyword generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate keywords: ${error.message}`);
        }
    }

    static async generateTitle(topic) {
        try {
            const model = getModel();
            const prompt = `Generate 1 engaging title for the topic: ${topic}. 
                           The title should be very attractive and under 60 characters. 
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for title generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate title: ${error.message}`);
        }
    }

    static async generateMeta(topic) {
        try {
            const model = getModel();
            const prompt = `Generate meta description for the topic: ${topic}. 
                           The description should be under 160 characters and SEO optimized. 
                           Return only a JSON object with a single "description" field, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
                return JSON.parse(cleanResponse);
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return JSON.parse(result.choices[0].message.content);
            } else {
                throw new Error('Model not supported for meta generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate meta: ${error.message}`);
        }
    }

    static async generateContent(topic) {
        try {
            const model = getModel();
            const prompt = `Generate a detailed article about: ${topic}. 
                           Include introduction, main points, and conclusion.
                           Return only a JSON array of strings, without any markdown formatting or additional text.`;
            
            let result;
            if (getModelConfig().NAME === 'Gemini') {
                result = await model.generateContent(prompt);
                return result.response.text();
            } else if (getModelConfig().NAME === 'OpenAI') {
                result = await model.chat.completions.create({
                    model: getModelConfig().model,
                    messages: [{ role: 'user', content: prompt }],
                });
                return result.choices[0].message.content;
            } else {
                throw new Error('Model not supported for content generation.');
            }
        } catch (error) {
            throw new Error(`Failed to generate content: ${error.message}`);
        }
    }

    // In src/services/generatorService.js
    static async generateAllContent(topic) {
        try {
            const [keywords, titles, meta, content] = await Promise.all([
                this.generateKeywords(topic),
                this.generateTitle(topic),
                this.generateMeta(topic),
                this.generateContent(topic)
            ]);

            return {
                keywords,
                titles,
                meta,
                content
            };
        } catch (error) {
            throw new Error(`Failed to generate all content: ${error.message}`);
        }
    }

    static async switchModel(model) {
        try {
            const result = setModel(model);
            return result;
        } catch (error) {
            throw new Error(`Failed to switch model: ${error.message}`);
        }
    }
}

module.exports = GeneratorService;






const express = require('express');
const swaggerUi = require('swagger-ui-express');
const swaggerJsdoc = require('swagger-jsdoc');
const connectDB = require('./config/database');
const healthMonitor = require('./healthMonitor');
require('dotenv').config();

const app = express();

// Connect to MongoDB
connectDB();

// Middleware
app.use(express.json());

// Start health monitoring
healthMonitor.startMonitoring();

process.removeAllListeners('warning');
process.on('warning', (warning) => {
  if (warning.name === 'DeprecationWarning' && warning.message.includes('punycode')) {
    return;
  }
  console.warn(warning.name, warning.message);
});


// Swagger configuration
const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'Content Generation API',
            version: '1.0.0',
            description: 'API for generating SEO content, titles, meta descriptions, and more'
        },
        servers: [
            {
                url: '/'
            }
        ]
    },
    apis: ['./src/routes/*.js'] // Path to the API routes
};


const swaggerSpec = swaggerJsdoc(swaggerOptions);

// Serve Swagger UI
app.use('/api-docs', swaggerUi.serve);
app.get('/api-docs', swaggerUi.setup(swaggerSpec, {
    explorer: true,
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: "Content Generation API Documentation"
}));

// Routes
app.use('/api/generate', require('./routes/generatorRoutes'));
app.use('/api/health', require('./routes/healthRoutes'));

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
        success: false,
        error: 'Something went wrong!'
    });
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
    console.log(`Server running on port ${port}`);
    console.log(`Swagger documentation available at http://localhost:${port}/api-docs`);
});

module.exports = app;






const readline = require('readline');
const axios = require('axios');
const GeneratorService = require('./services/generatorService');

// Remove punycode deprecation warning
process.removeAllListeners('warning');
process.on('warning', (warning) => {
  if (warning.name === 'DeprecationWarning' && warning.message.includes('punycode')) {
    return;
  }
  console.warn(warning.name, warning.message);
});

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const API_URL = 'http://localhost:3000';

const COMMANDS = {
  SWITCH: '/switch',
  EXIT: 'exit',
  HELP: '/help',
  HEALTH: '/health',
  MODEL: '/model',
  HISTORY: '/history'
};

const AVAILABLE_MODELS = ['GEMINI', 'OPENAI', 'CLAUDE'];

async function showHelp() {
  console.log('\nAvailable commands:');
  console.log('/model   - Switch between AI models');
  console.log('/switch  - Switch between modes');
  console.log('/health  - Show current system health');
  console.log('/history - Show chat history');
  console.log('exit    - Exit current mode or program');
  console.log('/help   - Show this help message\n');
}

async function displayHealthCheck() {
  try {
    const response = await axios.get(`${API_URL}/api/health`);
    console.log('\nSystem Health Status:');
    console.log('===================');
    console.log(JSON.stringify(response.data, null, 2));
    console.log('===================\n');
  } catch (error) {
    console.error('Error fetching health status:', error.message);
  }
}

async function displayChatHistory() {
  try {
    const response = await axios.get(`${API_URL}/api/chat/history`);
    console.log('\nChat History:');
    console.log('===================');
    response.data.res.data.forEach((chat, index) => {
      console.log(`\nConversation ${index + 1}:`);
      console.log(`User: ${chat.userInput}`);
      console.log(`AI: ${chat.aiResponse}`);
      console.log(`Time: ${new Date(chat.timestamp).toLocaleString()}`);
      console.log('-------------------');
    });
  } catch (error) {
    console.error('Error fetching chat history:', error.message);
  }
}

async function switchModel() {
  return new Promise((resolve) => {
    console.log('\nAvailable Models:');
    AVAILABLE_MODELS.forEach((model, index) => {
      console.log(`${index + 1}. ${model}`);
    });
    
    rl.question('\nSelect model (1-3): ', async (choice) => {
      const modelIndex = parseInt(choice) - 1;
      if (modelIndex >= 0 && modelIndex < AVAILABLE_MODELS.length) {
        try {
          const result = await GeneratorService.switchModel(AVAILABLE_MODELS[modelIndex]);
          console.log(`\n${result}`);
          resolve(true);
        } catch (error) {
          console.error('Error switching model:', error.message);
          resolve(false);
        }
      } else {
        console.log('\nInvalid selection. Using default model.');
        resolve(false);
      }
    });
  });
}

async function handleChatMode() {
  console.clear();
  console.log('\n=== Chat Mode ===');
  console.log('Type your message or use commands (/help for list)\n');

  const chat = async () => {
    try {
      rl.question('You: ', async (input) => {
        if (input.toLowerCase() === COMMANDS.EXIT) {
          console.clear();
          showMainMenu();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HEALTH) {
          await displayHealthCheck();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HISTORY) {
          await displayChatHistory();
          chat();
          return;
        }

        try {
          const response = await axios.post(`${API_URL}/api/chat`, { message: input });
          console.log('\nAI:', response.data.res.data, '\n');
        } catch (error) {
          console.error('Error in chat:', error.response?.data?.error || error.message);
        }
        chat();
      });
    } catch (error) {
      console.error('Error in chat mode:', error.message);
      chat();
    }
  };

  chat();
}

async function handleGeneratorMode() {
  console.clear();
  console.log('\n=== Content Generator Mode ===');
  console.log('Select content type to generate:');
  console.log('1. Keywords');
  console.log('2. Title Suggestions');
  console.log('3. Meta Description');
  console.log('4. Full Content');
  console.log('5. Generate all together');
  console.log('Type "exit" to return to main menu');
  console.log('Type "/help" for available commands\n');

  const generator = async () => {
      try {
          rl.question('Select option (1-5): ', async (option) => {
                if (option.toLowerCase() === COMMANDS.EXIT) {
                    console.clear();
                    showMainMenu();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.HELP) {
                    await showHelp();
                    generator();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.HEALTH) {
                    await displayHealthCheck();
                    generator();
                    return;
                }

                if (option.toLowerCase() === COMMANDS.MODEL) {
                    await switchModel();
                    generator();
                    return;
                }

                let endpoint;
                let prompt;

                switch (option) {
                  case '1':
                      endpoint = '/api/generate/keywords';
                      prompt = 'Enter topic for keyword generation: ';
                      break;
                  case '2':
                      endpoint = '/api/generate/title';
                      prompt = 'Enter topic for title suggestions: ';
                      break;
                  case '3':
                      endpoint = '/api/generate/meta';
                      prompt = 'Enter topic for meta description: ';
                      break;
                  case '4':
                      endpoint = '/api/generate/content';
                      prompt = 'Enter topic for content generation: ';
                      break;
                  case '5':
                      endpoint = '/api/generate/all';
                      prompt = 'Enter topic to generate all content types: ';
                      break;
                  default:
                      console.log('Invalid option. Please choose 1-5.\n');
                      generator();
                      return;
              }

              rl.question(prompt, async (topic) => {
                  try {
                      console.log('\nGenerating content...\n');
                      const response = await axios.post(`${API_URL}${endpoint}`, { topic });
                      
                      console.log('Generated Successfully!\n');
                      console.log(JSON.stringify(response.data.data, null, 2));
                      console.log('\nSelect another option or type "exit" to return to main menu\n');
                  } catch (error) {
                      console.error('Error generating content:', error.response?.data?.error || error.message);
                  }
                  generator();
              });
          });
      } catch (error) {
          console.error('Error in generator mode:', error.message);
          generator();
      }
  };

  generator();
}


async function handleChatMode() {
  console.clear();
  console.log('\n=== Chat Mode ===');
  console.log('Type your message or use commands (/help for list)\n');

  const chat = async () => {
    try {
      rl.question('You: ', async (input) => {
        if (input.toLowerCase() === COMMANDS.EXIT) {
          console.clear();
          showMainMenu();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HEALTH) {
          await displayHealthCheck();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          chat();
          return;
        }

        try {
          const response = await axios.post(`${API_URL}/api/generate/content`, { topic: input });
          console.log('\nAI:', response.data.data, '\n');
        } catch (error) {
          console.error('Error in chat:', error.response?.data?.error || error.message);
        }
        chat();
      });
    } catch (error) {
      console.error('Error in chat mode:', error.message);
      chat();
    }
  };

  chat();
}

async function initialModelSelection() {
  console.log('Welcome to Content Generation CLI!\n');
  console.log('Please select your preferred AI model:');
  await switchModel();
}

async function showMainMenu() {
  console.log('\nAvailable modes:');
  console.log('1. Generator - Generate specific content types');
  console.log('2. Chat - Free conversation mode');
  console.log('Type "exit" to quit the program');
  console.log('Type "/help" for available commands\n');

  const selectMode = () => {
    try {
      rl.question('Select mode (1/2): ', async (mode) => {
        if (mode.toLowerCase() === COMMANDS.EXIT) {
          console.log('Goodbye!');
          rl.close();
          process.exit(0);
        }

        if (mode.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          selectMode();
          return;
        }

        if (mode.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          selectMode();
          return;
        }

        switch (mode) {
          case '1':
            await handleGeneratorMode();
            break;
          case '2':
            await handleChatMode();
            break;
          default:
            console.log('Invalid selection. Please choose 1 or 2.\n');
            selectMode();
        }
      });
    } catch (error) {
      console.error('Error in main menu:', error.message);
      selectMode();
    }
  };

  selectMode();
}

async function startChat() {
  console.clear();
  await initialModelSelection();
  showMainMenu();
}

// Handle process termination gracefully
process.on('SIGINT', () => {
  console.log('\nGoodbye!');
  rl.close();
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  rl.close();
  process.exit(1);
});

module.exports = startChat;





const mongoose = require('mongoose');

class HealthMonitor {
    constructor() {
        this.interval = null;
    }

    getHealthStatus() {
        return {
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available',
            timestamp: new Date().toISOString()
        };
    }

    logHealthStatus() {
        const status = this.getHealthStatus();
        console.log('\nSystem Health Status:');
        console.log('===================');
        console.log(`Status: ${status.status}`);
        console.log(`Uptime: ${status.uptime.toFixed(2)} seconds`);
        console.log(`Database: ${status.databaseStatus}`);
        console.log(`AI Model: ${status.aiModelStatus}`);
        console.log(`Timestamp: ${status.timestamp}`);
        console.log('===================\n');
    }

    startMonitoring(interval = 60000) {
        this.interval = setInterval(() => this.logHealthStatus(), interval);
    }

    stopMonitoring() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
    }
}

module.exports = new HealthMonitor();
