const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
    try {
        console.log('Attempting to connect to MongoDB...');
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('MongoDB connected successfully');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

module.exports = connectDB;





{
  "MODEL": ["GEMINI", "OPENAI", "CLAUDE"],
  "DEFAULT": "GEMINI",
  "GEMINI": {
      "NAME": "Gemini",
      "URL": "https://gemini.com/",
      "GEMINI_API_KEY": "AIzaSyARy3fYtDPg45Kl4IwlXShmhlsLtoTqB7c",
      "top_k": 5
  },
  "OPENAI": {
      "NAME": "OpenAI",
      "URL": "https://api.openai.com/",
      "OPENAI_API_KEY": "",
      "model": "gpt-4"
  },
  "CLAUDE": {
      "NAME": "Claude",
      "URL": "https://claude.com/",
      "CLAUDE_API_KEY": "",
      "model": "claude-1.0"
  }
}





// 2. src/models/chatModel.js
const mongoose = require('mongoose');

const chatSchema = new mongoose.Schema({
    requestType: {
        type: String,
        enum: ['content', 'title', 'meta', 'keywords'],
        required: true
    },
    input: {
        type: String,
        required: true
    },
    output: {
        type: mongoose.Schema.Types.Mixed,
        required: true
    },
    metadata: {
        processTime: Number,
        tokensUsed: Number,
        timestamp: {
            type: Date,
            default: Date.now
        }
    }
});

module.exports = mongoose.model('ChatsFinal', chatSchema);







// src/models/models.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');
const path = require('path');
const fs = require('fs');

// Load configuration from JSON file
const configPath = path.join(__dirname, '../config/models.json');
const modelsConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));

let currentModel = modelsConfig.DEFAULT;

const isModelAvailable = (modelName) => {
    const config = modelsConfig[modelName];
    switch (modelName) {
        case 'GEMINI':
            return !!config.GEMINI_API_KEY;
        case 'OPENAI':
            return !!config.OPENAI_API_KEY;
        case 'CLAUDE':
            return !!config.CLAUDE_API_KEY;
        default:
            return false;
    }
};

const getAvailableModels = () => {
    return modelsConfig.MODEL.filter(model => isModelAvailable(model));
};

const getModelConfig = () => {
    return modelsConfig[currentModel];
};

const setModel = (model) => {
    const upperModel = model.toUpperCase();
    if (!modelsConfig.MODEL.includes(upperModel)) {
        throw new Error(`Model ${model} not supported.`);
    }
    if (!isModelAvailable(upperModel)) {
        throw new Error(`Model ${model} is not available. API key not configured.`);
    }
    currentModel = upperModel;
    return `Switched to ${modelsConfig[currentModel].NAME} model.`;
};

const getModel = () => {
    const config = getModelConfig();
    if (!isModelAvailable(currentModel)) {
        throw new Error(`Current model ${currentModel} is not available. API key not configured.`);
    }

    switch (currentModel) {
        case 'GEMINI':
            const genAI = new GoogleGenerativeAI(config.GEMINI_API_KEY);
            return genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        case 'OPENAI':
            if (!config.OPENAI_API_KEY) {
                throw new Error('OpenAI API key not configured');
            }
            return new OpenAI({ apiKey: config.OPENAI_API_KEY });
        case 'CLAUDE':
            if (!config.CLAUDE_API_KEY) {
                throw new Error('Claude integration not implemented yet');
            }
            throw new Error('Claude integration not implemented yet');
        default:
            throw new Error(`Model ${currentModel} not supported.`);
    }
};

module.exports = {
    getModel,
    setModel,
    getModelConfig,
    getAvailableModels,
    isModelAvailable
};





// 2. Update generatorRoutes.js to add missing endpoints
const express = require('express');
const router = express.Router();
const GeneratorService = require('../services/generatorService');
const Chat = require('../models/chatModel');

// Existing keywords endpoint
router.post('/keywords', async (req, res) => {
    try {
        const startTime = Date.now();
        const keywords = await GeneratorService.generateKeywords(req.body.topic);
        
        const chat = new Chat({
            requestType: 'keywords',
            input: req.body.topic,
            output: keywords,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: keywords
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Existing title endpoint
router.post('/title', async (req, res) => {
    try {
        const startTime = Date.now();
        const titles = await GeneratorService.generateTitle(req.body.topic);
        
        const chat = new Chat({
            requestType: 'title',
            input: req.body.topic,
            output: titles,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: titles
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add meta endpoint
router.post('/meta', async (req, res) => {
    try {
        const startTime = Date.now();
        const meta = await GeneratorService.generateMeta(req.body.topic);
        
        const chat = new Chat({
            requestType: 'meta',
            input: req.body.topic,
            output: meta,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: meta
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add content endpoint
router.post('/content', async (req, res) => {
    try {
        const startTime = Date.now();
        const content = await GeneratorService.generateContent(req.body.topic);
        
        const chat = new Chat({
            requestType: 'content',
            input: req.body.topic,
            output: content,
            metadata: {
                processTime: Date.now() - startTime
            }
        });
        await chat.save();

        res.json({
            success: true,
            data: content
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Add switch model endpoint
router.post('/switch-model', async (req, res) => {
    try {
      const { model } = req.body;
      const result = await GeneratorService.switchModel(model);
      res.json({
        success: true,
        message: result
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

module.exports = router;






const express = require('express');
const router = express.Router();
const mongoose = require('mongoose'); // Import mongoose

/**
 * @swagger
 * /api/health:
 *   get:
 *     summary: Check system health
 *     description: Returns system health status including database and AI model availability
 *     tags: [Health]
 *     responses:
 *       200:
 *         description: System is healthy
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                 uptime:
 *                   type: number
 *                 databaseStatus:
 *                   type: string
 *                 aiModelStatus:
 *                   type: string
 */
router.get('/', async (req, res) => {
    try {
        const healthStatus = {
            status: 'healthy',
            uptime: process.uptime(),
            databaseStatus: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
            aiModelStatus: 'available'
        };
        
        res.json({
            success: true,
            data: healthStatus
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;






const { getModel, setModel, getModelConfig } = require('../models/models');

class GeneratorService {
  static async generateKeywords(topic) {
    const model = getModel();
    const prompt = `Generate 10 relevant SEO keywords for the topic: ${topic}. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for keyword generation.');
    }
  }

  static async generateTitle(topic) {
    const model = getModel();
    const prompt = `Generate 1 engaging title for the topic: ${topic}. 
                   The title should be very attractive and under 60 characters. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for title generation.');
    }
  }

  static async generateMeta(topic) {
    const model = getModel();
    const prompt = `Generate meta description for the topic: ${topic}. 
                   The description should be under 160 characters and SEO optimized. 
                   Return only a JSON object with a single "description" field, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for meta generation.');
    }
  }

  static async generateContent(topic) {
    const model = getModel();
    const prompt = `Generate a detailed article about: ${topic}. 
                   Include introduction, main points, and conclusion.
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      return result.response.text();
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return result.choices[0].message.content;
    } else {
      throw new Error('Model not supported for content generation.');
    }
  }

  static async switchModel(model) {
    setModel(model);
    return `Switched to ${getModelConfig().NAME} model.`;
  }
}

module.exports = GeneratorService;





const { getModel, setModel, getModelConfig } = require('../models/models');

class GeneratorService {
  static async generateKeywords(topic) {
    const model = getModel();
    const prompt = `Generate 10 relevant SEO keywords for the topic: ${topic}. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for keyword generation.');
    }
  }

  static async generateTitle(topic) {
    const model = getModel();
    const prompt = `Generate 1 engaging title for the topic: ${topic}. 
                   The title should be very attractive and under 60 characters. 
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for title generation.');
    }
  }

  static async generateMeta(topic) {
    const model = getModel();
    const prompt = `Generate meta description for the topic: ${topic}. 
                   The description should be under 160 characters and SEO optimized. 
                   Return only a JSON object with a single "description" field, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      const cleanResponse = result.response.text().replace(/```json\n|\n```/g, '').trim();
      return JSON.parse(cleanResponse);
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return JSON.parse(result.choices[0].message.content);
    } else {
      throw new Error('Model not supported for meta generation.');
    }
  }

  static async generateContent(topic) {
    const model = getModel();
    const prompt = `Generate a detailed article about: ${topic}. 
                   Include introduction, main points, and conclusion.
                   Return only a JSON array of strings, without any markdown formatting or additional text.`;
    
    let result;
    if (getModelConfig().NAME === 'Gemini') {
      result = await model.generateContent(prompt);
      return result.response.text();
    } else if (getModelConfig().NAME === 'OpenAI') {
      result = await model.chat.completions.create({
        model: getModelConfig().model,
        messages: [{ role: 'user', content: prompt }],
      });
      return result.choices[0].message.content;
    } else {
      throw new Error('Model not supported for content generation.');
    }
  }

  static async switchModel(model) {
    setModel(model);
    return `Switched to ${getModelConfig().NAME} model.`;
  }
}

module.exports = GeneratorService;






// cli.js
const readline = require('readline');
const axios = require('axios');
const GeneratorService = require('./services/generatorService');

// Suppress the punycode deprecation warning
process.removeAllListeners('warning');
process.on('warning', (warning) => {
  if (warning.name === 'DeprecationWarning' && warning.message.includes('punycode')) {
    return;
  }
  console.warn(warning.name, warning.message);
});

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const API_URL = 'http://localhost:3000';

const COMMANDS = {
  SWITCH: '/switch',
  EXIT: 'exit',
  HELP: '/help',
  HEALTH: '/health',
  MODEL: '/model'
};

const AVAILABLE_MODELS = ['GEMINI', 'OPENAI', 'CALUDE'];

async function showHelp() {
  console.log('\nAvailable commands:');
  console.log('/model  - Switch between AI models');
  console.log('/switch - Switch between modes');
  console.log('/health - Show current system health');
  console.log('exit   - Exit current mode or program');
  console.log('/help  - Show this help message\n');
}

async function displayHealthCheck() {
  try {
    const response = await axios.get(`${API_URL}/api/health`);
    console.log('\nSystem Health Status:');
    console.log('===================');
    console.log(JSON.stringify(response.data.data, null, 2));
    console.log('===================\n');
  } catch (error) {
    console.error('Error fetching health status:', error.message);
  }
}

async function switchModel() {
  return new Promise((resolve) => {
    console.log('\nAvailable Models:');
    AVAILABLE_MODELS.forEach((model, index) => {
      console.log(`${index + 1}. ${model}`);
    });
    
    rl.question('\nSelect model (1-3): ', async (choice) => {
      const modelIndex = parseInt(choice) - 1;
      if (modelIndex >= 0 && modelIndex < AVAILABLE_MODELS.length) {
        try {
          const result = await GeneratorService.switchModel(AVAILABLE_MODELS[modelIndex]);
          console.log(`\n${result}`);
          resolve(true);
        } catch (error) {
          console.error('Error switching model:', error.message);
          resolve(false);
        }
      } else {
        console.log('\nInvalid selection. Using default model.');
        resolve(false);
      }
    });
  });
}

async function handleGeneratorMode() {
  console.clear();
  console.log('\n=== Content Generator Mode ===');
  console.log('Select content type to generate:');
  console.log('1. Keywords');
  console.log('2. Title Suggestions');
  console.log('3. Meta Description');
  console.log('4. Full Content');
  console.log('Type "exit" to return to main menu');
  console.log('Type "/help" for available commands\n');

  const generator = async () => {
    try {
      rl.question('Select option (1-4): ', async (option) => {
        if (option.toLowerCase() === COMMANDS.EXIT) {
          console.clear();
          showMainMenu();
          return;
        }

        if (option.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          generator();
          return;
        }

        if (option.toLowerCase() === COMMANDS.HEALTH) {
          await displayHealthCheck();
          generator();
          return;
        }

        if (option.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          generator();
          return;
        }

        let endpoint;
        let prompt;

        switch (option) {
          case '1':
            endpoint = '/api/generate/keywords';
            prompt = 'Enter topic for keyword generation: ';
            break;
          case '2':
            endpoint = '/api/generate/title';
            prompt = 'Enter topic for title suggestions: ';
            break;
          case '3':
            endpoint = '/api/generate/meta';
            prompt = 'Enter topic for meta description: ';
            break;
          case '4':
            endpoint = '/api/generate/content';
            prompt = 'Enter topic for content generation: ';
            break;
          default:
            console.log('Invalid option. Please choose 1-4.\n');
            generator();
            return;
        }

        rl.question(prompt, async (topic) => {
          try {
            console.log('\nGenerating content...\n');
            const response = await axios.post(`${API_URL}${endpoint}`, { topic });
            console.log('Generated Successfully!\n');
            console.log(JSON.stringify(response.data.data, null, 2));
            console.log('\nSelect another option or type "exit" to return to main menu\n');
          } catch (error) {
            console.error('Error generating content:', error.response?.data?.error || error.message);
          }
          generator();
        });
      });
    } catch (error) {
      console.error('Error in generator mode:', error.message);
      generator();
    }
  };

  generator();
}

async function handleChatMode() {
  console.clear();
  console.log('\n=== Chat Mode ===');
  console.log('Type your message or use commands (/help for list)\n');

  const chat = async () => {
    try {
      rl.question('You: ', async (input) => {
        if (input.toLowerCase() === COMMANDS.EXIT) {
          console.clear();
          showMainMenu();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.HEALTH) {
          await displayHealthCheck();
          chat();
          return;
        }

        if (input.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          chat();
          return;
        }

        try {
          const response = await axios.post(`${API_URL}/api/generate/content`, { topic: input });
          console.log('\nAI:', response.data.data, '\n');
        } catch (error) {
          console.error('Error in chat:', error.response?.data?.error || error.message);
        }
        chat();
      });
    } catch (error) {
      console.error('Error in chat mode:', error.message);
      chat();
    }
  };

  chat();
}

async function initialModelSelection() {
  console.log('Welcome to Content Generation CLI!\n');
  console.log('Please select your preferred AI model:');
  await switchModel();
}

async function showMainMenu() {
  console.log('\nAvailable modes:');
  console.log('1. Generator - Generate specific content types');
  console.log('2. Chat - Free conversation mode');
  console.log('Type "exit" to quit the program');
  console.log('Type "/help" for available commands\n');

  const selectMode = () => {
    try {
      rl.question('Select mode (1/2): ', async (mode) => {
        if (mode.toLowerCase() === COMMANDS.EXIT) {
          console.log('Goodbye!');
          rl.close();
          process.exit(0);
        }

        if (mode.toLowerCase() === COMMANDS.HELP) {
          await showHelp();
          selectMode();
          return;
        }

        if (mode.toLowerCase() === COMMANDS.MODEL) {
          await switchModel();
          selectMode();
          return;
        }

        switch (mode) {
          case '1':
            await handleGeneratorMode();
            break;
          case '2':
            await handleChatMode();
            break;
          default:
            console.log('Invalid selection. Please choose 1 or 2.\n');
            selectMode();
        }
      });
    } catch (error) {
      console.error('Error in main menu:', error.message);
      selectMode();
    }
  };

  selectMode();
}

async function startChat() {
  console.clear();
  await initialModelSelection();
  showMainMenu();
}

// Handle process termination gracefully
process.on('SIGINT', () => {
  console.log('\nGoodbye!');
  rl.close();
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  rl.close();
  process.exit(1);
});

module.exports = startChat;